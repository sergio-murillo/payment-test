@startuml Flujo Completo de Pago
title Flujo Completo de Pago - Cliente a Payment Gateway (Actualizado)

actor Cliente
participant Frontend
participant "ProductsController" as PC
participant "GetProductUseCase" as GPU
participant "ProductRepository" as PR
participant "CheckoutPage" as Checkout
participant "TransactionsController" as TC
participant "CreateTransactionUseCase" as CTU
participant "TransactionRepository" as TR
participant "EventStoreService" as ES
participant "PaymentsController" as PayC
participant "ProcessPaymentUseCase" as PPU
participant "StepFunctionsService" as SFS
participant "PaymentGatewayAdapter" as WPA
participant "Payment Gateway API" as Gateway
participant "UpdateInventoryUseCase" as UIU
participant "InventoryRepository" as IR
participant "CompensateTransactionUseCase" as CTUComp

== Visualización de Producto ==
Cliente -> Frontend: Accede a página de producto
Frontend -> PC: GET /products/:id
PC -> GPU: execute(productId)
GPU -> PR: findById(productId)
PR --> GPU: Product
GPU --> PC: Result<Product>
PC --> Frontend: Product data
Frontend --> Cliente: Muestra producto

== Inicio de Checkout ==
Cliente -> Frontend: Hace clic en "Pagar"
Frontend -> Frontend: router.push('/checkout/:productId')
Frontend -> Checkout: Carga página de checkout
Checkout -> PC: GET /products/:productId
PC --> Checkout: Product data
Checkout --> Cliente: Muestra formulario de pago

== Creación de Transacción y Procesamiento ==
Cliente -> Frontend: Completa formulario de pago\n(datos personales + tarjeta)
Frontend -> TC: POST /transactions\n(datos personales)
TC -> CTU: execute(dto)
CTU -> TR: findByIdempotencyKey(key)
alt Transacción ya existe
    TR --> CTU: Existing Transaction
    CTU --> TC: Result (existing)
else Nueva transacción
    TR --> CTU: null
    CTU -> CTU: create Transaction (PENDING)
    CTU -> TR: save(transaction)
    CTU -> ES: storeEvent(TransactionCreated)
    CTU --> TC: Result (new transaction)
end
TC --> Frontend: Transaction created

Frontend -> PayC: POST /payments/process\n(cardNumber, cvc, expMonth, expYear, cardHolder)
PayC -> PPU: execute(paymentDto)
PPU -> TR: findById(transactionId)
TR --> PPU: Transaction

== Tokenización de Tarjeta ==
PPU -> WPA: tokenizeCard(cardData)
WPA -> Gateway: POST /v1/tokens/cards\n(Authorization: public_key)
Gateway --> WPA: Token Response
WPA --> PPU: paymentToken

alt Tokenización fallida
    PPU --> PayC: Error
    PayC --> Frontend: Payment failed
else Tokenización exitosa
    PPU -> PPU: paymentToken obtenido
    
    == Procesamiento de Pago ==
    alt Step Function disponible
PPU -> SFS: startExecution(paymentData)
SFS -> SFS: Step Function iniciada
PPU --> PayC: Execution ARN
PayC --> Frontend: Payment processing started

== Step Function: Procesar Pago ==
        SFS -> WPA: createPayment(paymentToken, transactionData)
        WPA -> Gateway: GET /merchants/:public_key
        Gateway --> WPA: acceptance_token
        WPA -> WPA: calculateSignature()
WPA -> Gateway: POST /transactions
Gateway --> WPA: Payment Response
WPA --> SFS: Payment Result
        
        alt Pago PENDING (asíncrono)
            SFS -> TR: update(transaction.setGatewayTransactionId())
            SFS -> PPU: pollPaymentStatus(gatewayTransactionId)
            note right of PPU: Polling cada 10s\nhasta 2 minutos
            loop Polling de estado
                PPU -> WPA: getPaymentStatus(gatewayTransactionId)
                WPA -> Gateway: GET /v1/transactions/:id
                Gateway --> WPA: Payment Status
                WPA --> PPU: Status Response
                alt Status != PENDING
                    PPU -> TR: update(transaction con estado final)
                    PPU -> PPU: Stop polling
                end
            end
        end

alt Pago Aprobado
    SFS -> TR: update(transaction.approve())
    SFS -> ES: storeEvent(PaymentProcessed)
    SFS -> UIU: execute(productId, quantity)
    UIU -> IR: decrement(productId, quantity)
    note right of IR: Actualización atómica\ncon condición de carrera
    IR --> UIU: Updated Inventory
    UIU -> ES: storeEvent(InventoryUpdated)
    UIU --> SFS: Success
else Pago Declinado
    SFS -> TR: update(transaction.decline())
    SFS -> ES: storeEvent(PaymentDeclined)
            SFS -> CTUComp: execute(transactionId)
            CTUComp -> TR: update(transaction.cancel())
            CTUComp -> ES: storeEvent(TransactionCompensated)
            CTUComp --> SFS: Compensation completed
        end
    else Step Function no disponible (desarrollo)
        note right of PPU: Fallback: ejecución directa\nen desarrollo
        PPU -> PPU: executePaymentStep()
        PPU -> WPA: createPayment(paymentToken, transactionData)
        WPA -> Gateway: GET /merchants/:public_key
        Gateway --> WPA: acceptance_token
        WPA -> WPA: calculateSignature()
        WPA -> Gateway: POST /transactions
        Gateway --> WPA: Payment Response
        
        alt Pago PENDING (asíncrono)
            PPU -> TR: update(transaction.setGatewayTransactionId())
            PPU -> PPU: pollPaymentStatus(gatewayTransactionId)
            note right of PPU: Polling cada 10s\nhasta 2 minutos
            loop Polling de estado
                PPU -> WPA: getPaymentStatus(gatewayTransactionId)
                WPA -> Gateway: GET /v1/transactions/:id
                Gateway --> WPA: Payment Status
                WPA --> PPU: Status Response
                alt Status != PENDING
                    PPU -> TR: update(transaction con estado final)
                    PPU -> PPU: Stop polling
                end
            end
        end
        
        alt Pago Aprobado
            PPU -> TR: update(transaction.approve())
            PPU -> ES: storeEvent(PaymentProcessed)
            PPU -> UIU: execute(productId, quantity)
            UIU -> IR: decrement(productId, quantity)
            IR --> UIU: Updated Inventory
            UIU -> ES: storeEvent(InventoryUpdated)
            UIU --> PPU: Success
        else Pago Declinado
            PPU -> TR: update(transaction.decline())
            PPU -> ES: storeEvent(PaymentDeclined)
            PPU -> CTUComp: execute(transactionId)
            CTUComp -> TR: update(transaction.cancel())
            CTUComp -> ES: storeEvent(TransactionCompensated)
            CTUComp --> PPU: Compensation completed
        end
        
        PPU --> PayC: Payment processed
        PayC --> Frontend: Payment result
    end
end

== Consulta de Estado (Polling Frontend) ==
loop Polling de estado (Frontend)
    Frontend -> TC: GET /transactions/:id
TC -> TR: findById(transactionId)
TR --> TC: Transaction
TC --> Frontend: Transaction status
    
    alt Transaction status != PENDING
        Frontend -> Frontend: Stop polling
        Frontend --> Cliente: Muestra resultado final
    end
end

@enduml

@startuml Flujo de Actualización de Inventario con Condiciones de Carrera
title Manejo de Condiciones de Carrera en Inventario

participant "UpdateInventoryUseCase" as UIU
participant "InventoryRepository" as IR
participant "DynamoDB" as DB
participant "EventStoreService" as ES

== Escenario: Múltiples Actualizaciones Concurrentes ==

par Transacción 1
    UIU -> IR: decrement(productId, 1)
    IR -> DB: UPDATE inventory\nSET quantity = quantity - :qty\nWHERE quantity >= :qty
    DB --> IR: Success
    IR -> DB: GET inventory
    DB --> IR: Updated Inventory
    IR --> UIU: Inventory (qty: 49)
    UIU -> ES: storeEvent(InventoryUpdated)
end

par Transacción 2 (Concurrente)
    UIU -> IR: decrement(productId, 1)
    IR -> DB: UPDATE inventory\nSET quantity = quantity - :qty\nWHERE quantity >= :qty
    note right of DB: Condición verifica\ncantidad disponible
    DB --> IR: Success
    IR -> DB: GET inventory
    DB --> IR: Updated Inventory
    IR --> UIU: Inventory (qty: 48)
    UIU -> ES: storeEvent(InventoryUpdated)
end

note over DB: DynamoDB garantiza atomicidad\nmediante transacciones condicionales

@enduml

@startuml Flujo de Compensación (Saga Pattern)
title Operación de Compensación - Rollback de Transacción

participant "Step Function" as SF
participant "CompensateTransactionUseCase" as CTU
participant "TransactionRepository" as TR
participant "InventoryRepository" as IR
participant "EventStoreService" as ES
participant "SnsService" as SNS
participant "DynamoDB" as DB

== Escenario: Error en Procesamiento de Pago ==

SF -> SF: Error en procesamiento
SF -> CTU: execute(transactionId)

CTU -> TR: findById(transactionId)
TR --> CTU: Transaction

CTU -> TR: update(transaction.cancel())
TR -> DB: UPDATE transaction\nSET status = CANCELLED
DB --> TR: Success

CTU -> IR: release(productId, quantity)
IR -> DB: UPDATE inventory\nSET reservedQuantity = reservedQuantity - :qty
note right of DB: Libera inventario reservado
DB --> IR: Success
IR --> CTU: Updated Inventory

CTU -> ES: storeEvent(TransactionCompensated)
ES -> DB: PUT event-store
DB --> ES: Success

CTU -> SNS: publish(TransactionCompensated)
SNS --> CTU: Published

CTU --> SF: Compensation completed

note over SF, DB: Todas las operaciones se revierten\npara mantener consistencia

@enduml

@startuml Flujo de Idempotencia
title Garantía de Idempotencia en Transacciones

actor Cliente
participant Frontend
participant "CreateTransactionUseCase" as CTU
participant "TransactionRepository" as TR
participant "DynamoDB" as DB

== Escenario: Reintento de Petición ==

Cliente -> Frontend: Envía formulario de pago
Frontend -> CTU: createTransaction(dto)\nidempotencyKey: "abc-123"

CTU -> TR: findByIdempotencyKey("abc-123")
TR -> DB: QUERY transactions\nBY idempotencyKey-index
DB --> TR: Transaction exists
TR --> CTU: Existing Transaction

CTU --> Frontend: Result (existing transaction)
note right of CTU: No se crea duplicado\nSe retorna transacción existente

== Escenario: Primera Petición ==

Cliente -> Frontend: Envía formulario de pago
Frontend -> CTU: createTransaction(dto)\nidempotencyKey: "xyz-789"

CTU -> TR: findByIdempotencyKey("xyz-789")
TR -> DB: QUERY transactions\nBY idempotencyKey-index
DB --> TR: null (not found)
TR --> CTU: null

CTU -> CTU: create new Transaction
CTU -> TR: save(transaction)
TR -> DB: PUT transaction
DB --> TR: Success
TR --> CTU: Saved

CTU --> Frontend: Result (new transaction)

@enduml

@startuml Flujo Frontend - Redux y API
title Interacción Frontend con Backend usando Redux (Actualizado)

actor Usuario
participant "ProductPage" as ProductPage
participant "CheckoutPage" as CheckoutPage
participant "PaymentForm" as PaymentForm
participant "Redux Store" as Store
participant "Redux Thunk" as Thunk
participant "API Client" as API
participant "Backend API" as Backend

== Carga de Productos ==

Usuario -> ProductPage: Visita página de producto
ProductPage -> Store: dispatch(fetchProduct(id))
Store -> Thunk: fetchProduct(id)
Thunk -> API: GET /products/:id
API -> Backend: HTTP GET /products/:id
Backend --> API: Product data
API --> Thunk: Response data
Thunk -> Store: productsSlice.fulfilled(product)
Store --> ProductPage: State updated
ProductPage --> Usuario: Renderiza producto

== Inicio de Checkout ==

Usuario -> ProductPage: Hace clic en "Pagar"
ProductPage -> ProductPage: router.push('/checkout/:productId')
ProductPage -> CheckoutPage: Navega a checkout
CheckoutPage -> Store: dispatch(fetchProduct(productId))
Store -> Thunk: fetchProduct(productId)
Thunk -> API: GET /products/:productId
API -> Backend: HTTP GET /products/:productId
Backend --> API: Product data
API --> Thunk: Response data
Thunk -> Store: productsSlice.fulfilled(product)
Store --> CheckoutPage: State updated
CheckoutPage -> PaymentForm: Renderiza formulario
PaymentForm --> Usuario: Muestra formulario de pago

== Creación de Transacción y Procesamiento ==

Usuario -> PaymentForm: Completa formulario\n(datos personales + tarjeta)
PaymentForm -> PaymentForm: handlePaymentSubmit()
PaymentForm -> Store: dispatch(createTransaction(data))
Store -> Thunk: createTransaction(data)
Thunk -> API: POST /transactions
API -> Backend: HTTP POST /transactions
Backend --> API: Transaction created
API --> Thunk: Transaction data
Thunk -> Store: transactionSlice.fulfilled(transaction)
Store --> PaymentForm: State updated

PaymentForm -> PaymentForm: setProcessing(true)
PaymentForm -> Store: dispatch(processPayment(cardData))
Store -> Thunk: processPayment(cardData)
Thunk -> API: POST /payments/process\n{transactionId, cardNumber, cvc, expMonth, expYear, cardHolder}
API -> Backend: HTTP POST /payments/process
Backend --> API: Payment processing started
API --> Thunk: Response
Thunk -> Store: processPayment.fulfilled()
Store --> PaymentForm: State updated
PaymentForm --> Usuario: Muestra loader de progreso

== Polling de Estado ==

loop Polling cada 2 segundos (máx 15 intentos)
    PaymentForm -> Store: dispatch(fetchTransaction(transactionId))
    Store -> Thunk: fetchTransaction(transactionId)
    Thunk -> API: GET /transactions/:id
    API -> Backend: HTTP GET /transactions/:id
    Backend --> API: Transaction status
    API --> Thunk: Transaction data
    Thunk -> Store: transactionSlice.fulfilled(transaction)
    Store --> PaymentForm: State updated
    
    alt Transaction status != PENDING
        PaymentForm -> PaymentForm: Stop polling
        PaymentForm -> PaymentForm: setProcessing(false)
        PaymentForm --> Usuario: Muestra resultado final\n(APPROVED o DECLINED)
    end
end

@enduml

@startuml Flujo de Event Store y Auditoría
title Event Sourcing y Auditoría

participant "Use Case" as UC
participant "EventStoreController" as ESC
participant "GetAllEventsUseCase" as GAEU
participant "EventStoreService" as ES
participant "DynamoDB" as DB
participant "SnsService" as SNS
participant "SNS Topic" as Topic
participant "Subscribers" as Subs

== Almacenamiento de Evento ==

UC -> ES: storeEvent(eventData)
ES -> ES: create Event entity
ES -> DB: PUT event-store\naggregateId + eventTimestamp
note right of DB: Evento almacenado\npara auditoría
DB --> ES: Success
ES --> UC: Event stored

== Publicación de Evento ==

UC -> SNS: publish(event)
SNS -> Topic: Publish message
Topic -> Subs: Notify subscribers
note right of Subs: Múltiples suscriptores\npueden procesar el evento

== Consulta de Eventos por Agregado ==

UC -> ES: getEventsByAggregateId(id)
ES -> DB: QUERY event-store\nBY aggregateId
DB --> ES: Events array
ES -> ES: sort by timestamp
ES --> UC: Events history

== Consulta de Todos los Eventos ==

UC -> ESC: GET /event-store
ESC -> GAEU: execute()
GAEU -> DB: SCAN event-store
DB --> GAEU: All events
GAEU -> GAEU: sort by timestamp
GAEU --> ESC: Events array
ESC --> UC: All events

note over UC, DB: Event Store permite:\n- Auditoría completa\n- Reconstrucción de estado\n- Análisis de eventos\n- Consulta de todos los eventos

@enduml

@startuml Flujo de Step Functions
title Orquestación con AWS Step Functions (con Fallback)

participant "ProcessPaymentUseCase" as PPU
participant "StepFunctionsService" as SFS
participant "Step Function" as SF
participant "PaymentGatewayAdapter" as WPA
participant "Payment Gateway API" as Gateway
participant "UpdateInventoryUseCase" as UIU
participant "CompensateTransactionUseCase" as CTU

== Flujo con Step Function (Producción) ==

PPU -> SFS: startExecution(paymentData)
SFS -> SF: Start execution

SF -> WPA: createPayment(paymentToken, transactionData)
WPA -> Gateway: GET /merchants/:public_key
Gateway --> WPA: acceptance_token
WPA -> WPA: calculateSignature()
WPA -> Gateway: POST /transactions
Gateway --> WPA: Payment Response

alt Pago PENDING (asíncrono)
    SF -> PPU: pollPaymentStatus(gatewayTransactionId)
    loop Polling cada 10s hasta 2 minutos
        PPU -> WPA: getPaymentStatus(gatewayTransactionId)
        WPA -> Gateway: GET /v1/transactions/:id
        Gateway --> WPA: Payment Status
        WPA --> PPU: Status Response
        alt Status != PENDING
            PPU -> PPU: Stop polling
        end
    end
end

alt Pago Aprobado
    SF -> UIU: execute(productId, quantity)
    UIU -> UIU: Decrement inventory
    UIU --> SF: Inventory updated
    SF -> SF: Complete transaction (APPROVED)
else Pago Declinado
    SF -> CTU: execute(transactionId)
    CTU -> CTU: Cancel transaction
    CTU -> CTU: Compensate inventory
    CTU --> SF: Compensated
end

SF --> SFS: Execution completed
SFS --> PPU: Success/Error

== Flujo sin Step Function (Desarrollo) ==

PPU -> SFS: startExecution(paymentData)
SFS -> SFS: StateMachineDoesNotExist
SFS --> PPU: Error (Step Function no encontrada)

PPU -> PPU: executePaymentStep() (fallback)
PPU -> WPA: createPayment(paymentToken, transactionData)
WPA -> Gateway: GET /merchants/:public_key
Gateway --> WPA: acceptance_token
WPA -> WPA: calculateSignature()
WPA -> Gateway: POST /transactions
Gateway --> WPA: Payment Response

alt Pago PENDING (asíncrono)
    PPU -> PPU: pollPaymentStatus(gatewayTransactionId)
    loop Polling cada 10s hasta 2 minutos
        PPU -> WPA: getPaymentStatus(gatewayTransactionId)
        WPA -> Gateway: GET /v1/transactions/:id
        Gateway --> WPA: Payment Status
        WPA --> PPU: Status Response
        alt Status != PENDING
            PPU -> PPU: Stop polling
        end
    end
end

alt Pago Aprobado
    PPU -> UIU: execute(productId, quantity)
    UIU -> UIU: Decrement inventory
    UIU --> PPU: Inventory updated
    PPU -> PPU: Complete transaction (APPROVED)
else Pago Declinado
    PPU -> CTU: execute(transactionId)
    CTU -> CTU: Cancel transaction
    CTU -> CTU: Compensate inventory
    CTU --> PPU: Compensated
end

PPU --> PPU: Payment processed

note over PPU, CTU: En desarrollo, si Step Function\nno está disponible, se ejecuta\ndirectamente el flujo de pago

@enduml

@startuml Endpoints de Consulta
title Endpoints para Obtener Todos los Registros

actor Usuario
participant "EventStoreController" as ESC
participant "GetAllEventsUseCase" as GAEU
participant "InventoryController" as IC
participant "GetAllInventoryUseCase" as GAIU
participant "TransactionsController" as TC
participant "GetAllTransactionsUseCase" as GATU
participant "DynamoDB" as DB

== Obtener Todos los Eventos ==

Usuario -> ESC: GET /event-store
ESC -> GAEU: execute()
GAEU -> DB: SCAN event-store
DB --> GAEU: All events
GAEU -> GAEU: sort by timestamp (ascending)
GAEU --> ESC: Events array
ESC --> Usuario: All events from event-store

== Obtener Todo el Inventario ==

Usuario -> IC: GET /inventory
IC -> GAIU: execute()
GAIU -> DB: SCAN inventory
DB --> GAIU: All inventory items
GAIU --> IC: Inventory array
IC --> Usuario: All inventory items

== Obtener Todas las Transacciones ==

Usuario -> TC: GET /transactions
TC -> GATU: execute()
GATU -> DB: SCAN transactions
DB --> GATU: All transactions
GATU -> GATU: sort by createdAt (descending)
GATU --> TC: Transactions array
TC --> Usuario: All transactions (most recent first)

note over ESC, DB: Estos endpoints permiten:\n- Auditoría completa del sistema\n- Consulta de todos los registros\n- Análisis y debugging\n- Monitoreo del estado del sistema

@enduml
